# -*- coding: utf-8 -*-
"""2025_3_12_api_roadmap_withoutdesign_sleep.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fmIZDdbQvBOD68TubS_gYwkOTWuYnNHW
"""

# Install required packages
!pip install flask flask-sqlalchemy pymongo dnspython scikit-learn spacy geopy pyngrok gunicorn
!pip install uvicorn fastapi

# Download the English language model for spaCy
!python -m spacy download en_core_web_sm

# Create travel_algorithm.py
with open('travel_algorithm.py', 'w') as f:
    f.write("""
import pymongo
import urllib.parse
import spacy
from sklearn.preprocessing import MinMaxScaler
from geopy.distance import geodesic
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Connect to MongoDB
password = "master2002_B*"
encoded_password = urllib.parse.quote_plus(password)
MONGO_URI = f"mongodb+srv://abdelrahman:{encoded_password}@cluster0.goxvb.mongodb.net/travel_app?retryWrites=true&w=majority"
client = pymongo.MongoClient(MONGO_URI)
db = client["travel_app"]

# Define Collections
users_collection = db["users"]
places_collection = db["places"]
interactions_collection = db["interactions"]
search_queries_collection = db["search_queries"]
travel_preferences_collection = db["user_travel_preferences"]

# Load NLP Model
try:
    nlp = spacy.load("en_core_web_sm")
    logger.info("‚úÖ NLP Model Loaded!")
except Exception as e:
    logger.error(f"‚ùå Error loading NLP model: {e}")

# User preferences functions
def get_user_preferences(user_id):
    user = db.users.find_one({"_id": user_id})
    if not user:
        return None
    return {
        "preferred_categories": user.get("preferred_categories", []),
        "budget": user.get("budget", "medium"),
        "preferred_tags": user.get("preferred_tags", []),
    }

def get_user_travel_preferences(user_id):
    travel_prefs = db.user_travel_preferences.find_one({"user_id": user_id})
    if not travel_prefs:
        return None
    return {
        "destinations": travel_prefs.get("destinations", []),
        "travel_dates": travel_prefs.get("travel_dates", ""),
        "travel_type": travel_prefs.get("travel_type", "solo"),
        "accessibility_needs": travel_prefs.get("accessibility_needs", [])
    }

def get_filtered_places(user_id):
    travel_prefs = get_user_travel_preferences(user_id)
    if not travel_prefs or not travel_prefs["destinations"]:
        return list(db.places.find())

    preferred_cities = travel_prefs["destinations"]
    required_accessibility = travel_prefs.get("accessibility_needs", [])

    filtered_places = list(db.places.find({"location.city": {"$in": preferred_cities}}))

    if required_accessibility:
        filtered_places = [
            place for place in filtered_places
            if any(need in place.get("accessibility", []) for need in required_accessibility)
        ]

    return filtered_places

def compute_similarity(place, user_prefs, travel_prefs):
    score = 0

    if place["category"] in user_prefs["preferred_categories"]:
        score += 5

    for tag in place["tags"]:
        if tag in user_prefs["preferred_tags"]:
            score += 3

    for need in travel_prefs["accessibility_needs"]:
        if need in place.get("accessibility", []):
            score += 2

    return score

def rank_places_content_based(user_id):
    user_prefs = get_user_preferences(user_id)
    travel_prefs = get_user_travel_preferences(user_id)

    if not user_prefs or not travel_prefs:
        return []

    filtered_places = get_filtered_places(user_id)

    ranked_places = sorted(
        filtered_places,
        key=lambda p: compute_similarity(p, user_prefs, travel_prefs),
        reverse=True
    )

    return ranked_places

def get_places_from_similar_users(user_id):
    user_prefs = get_user_preferences(user_id)
    if not user_prefs:
        return []

    similar_users = list(db.users.find({
        "preferred_categories": {"$in": user_prefs["preferred_categories"]},
        "preferred_tags": {"$in": user_prefs["preferred_tags"]}
    }))

    recommended_places = set()

    for user in similar_users:
        user_interactions = list(db.interactions.find({"user_id": user["_id"], "action": "like"}))
        for interaction in user_interactions:
            place = db.places.find_one({"_id": interaction["place_id"]})
            if place:
                recommended_places.add(place["_id"])

    return list(recommended_places)

def get_backup_places(user_id, existing_places):
    travel_prefs = get_user_travel_preferences(user_id)
    if not travel_prefs or not travel_prefs["destinations"]:
        return []

    preferred_cities = travel_prefs["destinations"]

    all_places = list(db.places.find({"_id": {"$nin": [p["_id"] for p in existing_places]}}))

    selected_places = list(db.places.find({"location.city": {"$in": preferred_cities}}))
    if not selected_places:
        return []

    avg_lat = sum([p["location"]["latitude"] for p in selected_places]) / len(selected_places)
    avg_lon = sum([p["location"]["longitude"] for p in selected_places]) / len(selected_places)
    user_center_location = (avg_lat, avg_lon)

    all_places.sort(key=lambda p: geodesic(user_center_location, (p["location"]["latitude"], p["location"]["longitude"])).km)

    return all_places[:10]

def generate_final_roadmap(user_id):
    logger.info(f"üéØ Generating Final Roadmap for {user_id}...")

    content_based = rank_places_content_based(user_id)
    collaborative = get_places_from_similar_users(user_id)

    all_recommended = []

    place_ids = set()
    for place in content_based:
        place_ids.add(place["_id"])
        all_recommended.append(place)

    for place_id in collaborative:
        if place_id not in place_ids:
            place = db.places.find_one({"_id": place_id})
            if place:
                all_recommended.append(place)
                place_ids.add(place_id)

    travel_prefs = get_user_travel_preferences(user_id)

    if not travel_prefs:
        logger.warning(f"No travel preferences found for user {user_id}")
        return []

    preferred_cities = set(travel_prefs.get("destinations", []))

    primary_places = [p for p in all_recommended if p["location"]["city"] in preferred_cities]

    if len(primary_places) < 10:
        needed = 10 - len(primary_places)
        backup_places = get_backup_places(user_id, primary_places)[:needed]
    else:
        backup_places = []

    final_roadmap = primary_places + backup_places

    return final_roadmap[:10]
""")

import os
import logging
from fastapi import FastAPI, Request, Query
from fastapi.responses import HTMLResponse, JSONResponse
from fastapi.templating import Jinja2Templates
from pyngrok import ngrok
import uvicorn
import travel_algorithm
from typing import Optional

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Create templates directory
os.makedirs('templates', exist_ok=True)

# Create the FastAPI application
app = FastAPI(title="Travel Roadmap API")

# Create a function to simplify roadmap to list format
def simplify_roadmap_to_list(roadmap_data):
    """
    Convert roadmap data to a simple list format without design elements
    """
    if not roadmap_data:
        return []

    simplified_list = []

    # Process a list of roadmaps
    if isinstance(roadmap_data, list):
        for item in roadmap_data:
            if isinstance(item, dict):
                # Extract essential information for each place
                place_info = {
                    "id": str(item.get("_id", "")),
                    "name": item.get("name", ""),
                    "description": item.get("description", ""),
                    "category": item.get("category", ""),
                    "location": {
                        "city": item["location"].get("city", ""),
                        "country": item["location"].get("country", "")
                    },
                    "rating": item.get("rating", 0),
                    "tags": item.get("tags", []),
                    "accessibility": item.get("accessibility", []),
                }
                simplified_list.append(place_info)
            elif isinstance(item, str):
                simplified_list.append(item)

    return simplified_list

# Routes
@app.get("/")
async def read_root():
    return {"message": "Welcome to the Travel Roadmap API"}

@app.get("/api/roadmap/{user_id}")
async def get_roadmap(user_id: str):
    """
    Get a travel roadmap as a simple list for a specific user
    """
    try:
        logger.info(f"Generating roadmap for user {user_id}")

        # Generate roadmap data
        roadmap_data = travel_algorithm.generate_final_roadmap(user_id)

        # Simplify to list format
        simplified_list = simplify_roadmap_to_list(roadmap_data)

        return {"success": True, "data": simplified_list}
    except Exception as e:
        logger.error(f"Error generating roadmap: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

from pydantic import BaseModel

class RoadmapRequest(BaseModel):
    user_id: str

@app.post("/api/roadmap")
async def create_roadmap(request: RoadmapRequest):
    """
    Generate a new travel roadmap for a user
    """
    try:
        logger.info(f"Generating roadmap for user {request.user_id}")

        # Generate roadmap data
        roadmap_data = travel_algorithm.generate_final_roadmap(request.user_id)

        # Simplify to list format
        simplified_list = simplify_roadmap_to_list(roadmap_data)

        return {"success": True, "data": simplified_list}
    except Exception as e:
        logger.error(f"Error generating roadmap: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.exception_handler(404)
async def not_found_exception_handler(request: Request, exc):
    return JSONResponse(
        status_code=404,
        content={"success": False, "error": "Resource not found"}
    )

@app.exception_handler(500)
async def server_exception_handler(request: Request, exc):
    return JSONResponse(
        status_code=500,
        content={"success": False, "error": "Internal server error"}
    )

# Apply nest_asyncio to fix the issue in Jupyter Notebook
import nest_asyncio
nest_asyncio.apply()

# Run the application
if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)

!pip install flask flask-sqlalchemy pymongo dnspython scikit-learn spacy geopy pyngrok uvicorn fastapi nest-asyncio

!python -m spacy download en_core_web_sm

# --- Step 1: Install required packages ---
# Run these commands to install needed packages

# --- Step 2: Import all required libraries ---
import os
import json
import logging
import pymongo
import urllib.parse
import spacy
import nest_asyncio
from fastapi import FastAPI, Request, Query
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from sklearn.preprocessing import MinMaxScaler
from geopy.distance import geodesic
from pyngrok import ngrok

# --- Step 3: Configure logging and apply nest_asyncio ---
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
nest_asyncio.apply()  # Allows the event loop to be nested (needed for Jupyter/Colab)

# --- Step 4: MongoDB connection setup ---
password = "master2002_B*"
encoded_password = urllib.parse.quote_plus(password)
MONGO_URI = f"mongodb+srv://abdelrahman:{encoded_password}@cluster0.goxvb.mongodb.net/travel_app?retryWrites=true&w=majority"

try:
    client = pymongo.MongoClient(MONGO_URI)
    db = client["travel_app"]

    # Define Collections
    users_collection = db["users"]
    places_collection = db["places"]
    interactions_collection = db["interactions"]
    search_queries_collection = db["search_queries"]
    travel_preferences_collection = db["user_travel_preferences"]

    logger.info("‚úÖ MongoDB connection established!")
except Exception as e:
    logger.error(f"‚ùå MongoDB connection error: {e}")

# --- Step 5: Load spaCy language model ---
try:
    nlp = spacy.load("en_core_web_sm")
    logger.info("‚úÖ NLP Model Loaded!")
except Exception as e:
    logger.error(f"‚ùå Error loading NLP model: {e}")
    logger.info("üîÑ Downloading spaCy model...")
    import spacy.cli
    spacy.cli.download("en_core_web_sm")
    nlp = spacy.load("en_core_web_sm")

# --- Step 6: Define travel algorithm functions ---
def get_user_preferences(user_id):
    """Get user general preferences"""
    user = db.users.find_one({"_id": user_id})
    if not user:
        return None
    return {
        "preferred_categories": user.get("preferred_categories", []),
        "budget": user.get("budget", "medium"),
        "preferred_tags": user.get("preferred_tags", []),
    }

def get_user_travel_preferences(user_id):
    """Get user travel-specific preferences"""
    travel_prefs = db.user_travel_preferences.find_one({"user_id": user_id})
    if not travel_prefs:
        return None
    return {
        "destinations": travel_prefs.get("destinations", []),
        "travel_dates": travel_prefs.get("travel_dates", ""),
        "travel_type": travel_prefs.get("travel_type", "solo"),
        "accessibility_needs": travel_prefs.get("accessibility_needs", [])
    }

def get_filtered_places(user_id):
    """Get places filtered by user's travel preferences"""
    travel_prefs = get_user_travel_preferences(user_id)
    if not travel_prefs or not travel_prefs["destinations"]:
        return list(db.places.find())

    preferred_cities = travel_prefs["destinations"]
    required_accessibility = travel_prefs.get("accessibility_needs", [])

    filtered_places = list(db.places.find({"location.city": {"$in": preferred_cities}}))

    if required_accessibility:
        filtered_places = [
            place for place in filtered_places
            if any(need in place.get("accessibility", []) for need in required_accessibility)
        ]

    return filtered_places

def compute_similarity(place, user_prefs, travel_prefs):
    """Compute similarity score between place and user preferences"""
    score = 0

    if place["category"] in user_prefs["preferred_categories"]:
        score += 5

    for tag in place["tags"]:
        if tag in user_prefs["preferred_tags"]:
            score += 3

    for need in travel_prefs["accessibility_needs"]:
        if need in place.get("accessibility", []):
            score += 2

    return score

def rank_places_content_based(user_id):
    """Rank places using content-based filtering"""
    user_prefs = get_user_preferences(user_id)
    travel_prefs = get_user_travel_preferences(user_id)

    if not user_prefs or not travel_prefs:
        return []

    filtered_places = get_filtered_places(user_id)

    ranked_places = sorted(
        filtered_places,
        key=lambda p: compute_similarity(p, user_prefs, travel_prefs),
        reverse=True
    )

    return ranked_places

def get_places_from_similar_users(user_id):
    """Get places from similar users (collaborative filtering)"""
    user_prefs = get_user_preferences(user_id)
    if not user_prefs:
        return []

    similar_users = list(db.users.find({
        "preferred_categories": {"$in": user_prefs["preferred_categories"]},
        "preferred_tags": {"$in": user_prefs["preferred_tags"]}
    }))

    recommended_places = set()

    for user in similar_users:
        user_interactions = list(db.interactions.find({"user_id": user["_id"], "action": "like"}))
        for interaction in user_interactions:
            place = db.places.find_one({"_id": interaction["place_id"]})
            if place:
                recommended_places.add(place["_id"])

    return list(recommended_places)

def get_backup_places(user_id, existing_places):
    """Get backup places in case we don't have enough recommendations"""
    travel_prefs = get_user_travel_preferences(user_id)
    if not travel_prefs or not travel_prefs["destinations"]:
        return []

    preferred_cities = travel_prefs["destinations"]

    all_places = list(db.places.find({"_id": {"$nin": [p["_id"] for p in existing_places]}}))

    selected_places = list(db.places.find({"location.city": {"$in": preferred_cities}}))
    if not selected_places:
        return []

    avg_lat = sum([p["location"]["latitude"] for p in selected_places]) / len(selected_places)
    avg_lon = sum([p["location"]["longitude"] for p in selected_places]) / len(selected_places)
    user_center_location = (avg_lat, avg_lon)

    all_places.sort(key=lambda p: geodesic(user_center_location, (p["location"]["latitude"], p["location"]["longitude"])).km)

    return all_places[:10]

def generate_final_roadmap(user_id):
    """Generate the final roadmap by combining content-based and collaborative filtering"""
    logger.info(f"üéØ Generating Final Roadmap for {user_id}...")

    content_based = rank_places_content_based(user_id)
    collaborative = get_places_from_similar_users(user_id)

    all_recommended = []

    place_ids = set()
    for place in content_based:
        place_ids.add(place["_id"])
        all_recommended.append(place)

    for place_id in collaborative:
        if place_id not in place_ids:
            place = db.places.find_one({"_id": place_id})
            if place:
                all_recommended.append(place)
                place_ids.add(place_id)

    travel_prefs = get_user_travel_preferences(user_id)

    if not travel_prefs:
        logger.warning(f"No travel preferences found for user {user_id}")
        return []

    preferred_cities = set(travel_prefs.get("destinations", []))

    primary_places = [p for p in all_recommended if p["location"]["city"] in preferred_cities]

    if len(primary_places) < 10:
        needed = 10 - len(primary_places)
        backup_places = get_backup_places(user_id, primary_places)[:needed]
    else:
        backup_places = []

    final_roadmap = primary_places + backup_places

    return final_roadmap[:10]

# --- Step 7: Define the Pydantic model for request validation ---
class RoadmapRequest(BaseModel):
    user_id: str

# --- Step 8: Function to simplify roadmap to list format ---
def simplify_roadmap_to_list(roadmap_data):
    """
    Convert roadmap data to a simple list format without design elements
    """
    if not roadmap_data:
        return []

    simplified_list = []

    # Process a list of roadmaps
    if isinstance(roadmap_data, list):
        for item in roadmap_data:
            if isinstance(item, dict):
                # Extract essential information for each place
                place_info = {
                    "id": str(item.get("_id", "")),
                    "name": item.get("name", ""),
                    "description": item.get("description", ""),
                    "category": item.get("category", ""),
                    "location": {
                        "city": item["location"].get("city", ""),
                        "country": item["location"].get("country", ""),
                        "latitude": item["location"].get("latitude", 0.0),
                        "longitude": item["location"].get("longitude", 0.0)
                    },
                    "rating": item.get("rating", 0),
                    "tags": item.get("tags", []),
                    "accessibility": item.get("accessibility", []),
                }
                simplified_list.append(place_info)
            elif isinstance(item, str):
                simplified_list.append(item)

    return simplified_list

# --- Step 9: Initialize FastAPI and enable CORS ---
app = FastAPI(
    title="Travel Roadmap API",
    description="API for generating travel roadmaps and recommendations",
    version="1.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# --- Step 10: Define API routes ---
@app.get("/")
async def read_root():
    return {"message": "Welcome to the Travel Roadmap API"}

@app.get("/api/roadmap/{user_id}")
async def get_roadmap(user_id: str):
    """
    Get a travel roadmap as a simple list for a specific user
    """
    try:
        logger.info(f"Generating roadmap for user {user_id}")

        # Generate roadmap data
        roadmap_data = generate_final_roadmap(user_id)

        # Simplify to list format
        simplified_list = simplify_roadmap_to_list(roadmap_data)

        return {"success": True, "data": simplified_list}
    except Exception as e:
        logger.error(f"Error generating roadmap: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

@app.post("/api/roadmap")
async def create_roadmap(request: RoadmapRequest):
    """
    Generate a new travel roadmap for a user
    """
    try:
        logger.info(f"Generating roadmap for user {request.user_id}")

        # Generate roadmap data
        roadmap_data = generate_final_roadmap(request.user_id)

        # Simplify to list format
        simplified_list = simplify_roadmap_to_list(roadmap_data)

        return {"success": True, "data": simplified_list}
    except Exception as e:
        logger.error(f"Error generating roadmap: {str(e)}")
        return JSONResponse(
            status_code=500,
            content={"success": False, "error": str(e)}
        )

# --- Step 11: Add error handlers ---
@app.exception_handler(404)
async def not_found_exception_handler(request: Request, exc):
    return JSONResponse(
        status_code=404,
        content={"success": False, "error": "Resource not found"}
    )

@app.exception_handler(500)
async def server_exception_handler(request: Request, exc):
    return JSONResponse(
        status_code=500,
        content={"success": False, "error": "Internal server error"}
    )

# --- Step 12: Setup Ngrok for public URL ---
def setup_ngrok():
    """Setup ngrok to create a public URL"""
    ngrok_auth_token = "2tOzgXqC9q7RoFvJBnFlqER0RqI_3TRVziyYCaG526B2HSEVj"

    if ngrok_auth_token:
        try:
            ngrok.set_auth_token(ngrok_auth_token)
            public_url = ngrok.connect(5000).public_url
            logger.info(f"‚úÖ Ngrok tunnel established at: {public_url}")
            return public_url
        except Exception as e:
            logger.error(f"‚ùå Ngrok Error: {e}")
            return None
    else:
        logger.warning("‚ö†Ô∏è No Ngrok auth token provided. Tunnel not established.")
        return None

# --- Step 13: Main execution block ---
if __name__ == "__main__":
    # Generate public URL with ngrok
    public_url = setup_ngrok()

    if public_url:
        print(f"\n‚úÖ Access the API at: {public_url}/api/roadmap/user001")
        print(f"‚úÖ Access the API documentation at: {public_url}/docs\n")
    else:
        print("‚ö†Ô∏è Failed to establish ngrok tunnel. Using local URL only.")
        print("‚úÖ API available at: http://127.0.0.1:5000/api/roadmap/user001")

    # Run the FastAPI application
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=5000)

# --- Step 14: Code to test the API (run separately after server is running) ---
"""
import requests
import json

# Replace with your actual URL
api_url = "YOUR_PUBLIC_URL/api/roadmap/user001"  # Use your actual ngrok URL

response = requests.get(api_url)

# Display the response
print("Status Code:", response.status_code)
if response.status_code == 200:
    data = response.json()
    print("\nResponse Data:")
    print(json.dumps(data, indent=2))

    # Check the simplified list format
    if "data" in data and isinstance(data["data"], list):
        print(f"\nSuccessfully received {len(data['data'])} recommendation items")
else:
    print("Error:", response.text)
"""

